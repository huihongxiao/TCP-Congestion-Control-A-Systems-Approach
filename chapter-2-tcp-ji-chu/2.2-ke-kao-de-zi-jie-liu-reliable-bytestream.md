# 2.2 可靠的字节流（Reliable Byte-Stream）

在IP协议的尽力而为（best-effort）传输模型之上，在运行于终端主机上的一对进程之间，TCP实现了可靠的字节流。这一节会详细描述TCP的实现，以助于更好的理解后面章节将要介绍的拥塞控制算法。

## 2.2.1 端到端的问题

TCP的核心是滑动窗口算法。TCP除了 大家熟悉的确认/超时/重传机制外，还必须解决下面的问题。

1. 因为TCP运行在互联网上的任意两个计算机上的两个进程之间，它需要一个明确的连接建立过程，使得传输的双方都同意与对方传输数据。在连接建立的过程中，TCP的传输双方需要共享状态以启动滑动窗口算法。传输结束后还需要关闭连接，这样每个终端才知道可以释放状态。
2. 不同的TCP 连接有可能有极其不同的 RTT（Round-trip time，往返时间）时间。例如，San Francisco 和 Boston之间相隔数千公里，它们之间的TCP 连接RTT 可能需要 100ms。然而，同一个房间的两个主机之间的 TCP 连接可能只需要 1ms 的 RTT。同一个 TCP 协议需要能同时支持这两种场景。更糟糕的是，Francisco 和 Boston之间的 TCP 连接可能在早上 3 点的时候 RTT 时 100ms，到了下午 3 点 RTT 就变成了 500ms。甚至在一个仅持续几分钟的 TCP 连接中，RTT也可能发生改变。这意味着，在滑动窗口算法中，触发重传的超时机制必须是自适应的。
3. 由于互联网的尽力而为传输特性，packet 在传输过程中可能会乱序。packet 轻微的乱序不会造成问题，因为滑动窗口算法可以基于 sequence number 正确的重排 packets，所以这不是真正的问题（╮(╯▽╰)╭）。互联网的尽力而为传输带来的真正问题时，packet 究竟可以多乱序，换句话说，一个 packet 最长会延时多久才到达目的地。在最糟的情况下，packet 可以在互联网上被耽搁无限久。每当一个 packet 被一个路由器转发时，IP header 中的 time-to-live（TTL）字段就会被减一，最终达到 0。此时，packet 会被丢弃（这种 packet 不会迟到）。TTL 在 IP 协议里被错误命名了，并且在 IPv6中被重新命名为更准确的 Hop Count。由于知道 IP 协议会在 TTL 耗尽之后丢弃 packet，所以 TCP 假设每个 packet 都有一个最大的生命周期。在 TCP 协议里，这个最大生命周期是 Maximum Segment Life(MSL)，当前的默认值是 120 秒。但这仅仅是个工程实现上的变量，因为 IP 协议并不会强制在 120 秒之后丢包，这个值仅仅时 TCP 预估一个 packet 在互联网上存活的最长时间。这个值的隐藏意义非常重要，TCP 需要准备好面对被耽误了很久的 packet 突然出现，尽管这个 packet 会使得滑动窗口算法处理起来很复杂。
4. 因为任何计算机都可以接入到互联网，分配给 TCP 连接的资源也千差万别，尤其考虑到任何一个主机都可以同时支持数百个 TCP 连接。这意味着 TCP 必须要有一种机制来使得两端能够“学习”到对方能够提供的资源（例如，对方有多少 buffer 空间）。这是流控（flow control）需要解决的问题。
5.
