# 7.3 HTTP性能提升（QUIC）未校正

随着1990年World Wide Web的发明，HTTP就一直存在，且一直运行在TCP之上。最开始的版本，HTTP/1.0，因为其使用TCP的方式不当，有着很多的性能问题，例如，每次请求一个对象都需要建立一个新的TCP连接，当收到返回之后又要关闭连接。随后提出的HTTP/1.1旨在更好的利用TCP。TCP在HTTP提出的20多年时间内持续作为其底层协议。

实际上，使用TCP来支持Web一直以来都是有问题的，尤其是一个可靠的顺序字节流并不完全时Web流量的模型。具体来说，因为大部分web页面包含了大量的对象（注，例如图片，html，css等），应该同时并发的请求多个对象，但是TCP只提供了一个字节流。如果丢了一个包，TCP会等待其成功的重传，之后再继续传输，而HTTP更乐于不受这一个丢包的影响，而继续接受其他不收这个丢包影响的对象。同时开多个TCP连接明显可以是个解决方案，但又有不能在多个连接之间共享拥塞信息的缺点。

其他的一些因素还包括：

* 高延时无线网络的广泛使用
* 单个设备使用多个网络（例如WiFI和蜂窝网）
* Web上越来越多的加密和认证连接

这一切使得人们认识到，HTTP最好使用一个新的传输层，而填补这个空白的协议就是QUIC。

QUIC于2012年起源于Google，随后被作为一个标准在IETF研究。目前已经可以看到大量的部署，大部分Web浏览器和很多主流的网站已经在使用QUIC，甚至在一些非HTTP的应用程序中也开始使用QUIC。可部署性是QUIC开发人员的一个关键考量。QUIC有很多复杂的部分——它的规范跨越了数百页的三个RFC，但我们在这里关注它的拥塞控制方法，它融合了我们在本书中迄今为止看到的许多想法。

与TCP一样，QUIC在数据的传输过程中构建拥塞控制，但是它也意识到没有完美的拥塞控制算法。所以，它也假设不通的发送端可以使用不同的算法。QUIC规范中的基本算法类似于TCP NewReno，但是发送端可以单方面的选择一个不同的算法，例如CUBIC。QUIC提供了可以用来探测丢包的所有机制，以供各种拥塞算法使用。

QUIC包含了很多设计使得丢包和拥塞的探测比TCP更加的健壮。例如，TCP一个packet不管它是第一次传输还是重传，都是用相同的序列号，而QUIC的序列号（叫做packet numbers）是严格递增的。更高的packet number表明packet更晚被发送，而更小的packet number表明packet更早被发送。这意味着总是能够区分一个packet究竟是第一次传输还是因为丢包或者超时而重传。

TCP的序列号指的时字节数，而QUIC的packet number直接表示的就是packet数量。QUIC的packet number空间很大，有61bit，所以不会像TCP的序列号一样溢出。

QUIC协议内置了选择性确认（selective ACK），且比TCP的SACK option中最多支持确认3段数据更多。这提升了在高丢包环境的性能，使得传输能够继续，只要部分packet被成功收到了。

相比TCP快速重传中的重复ACK，QUIC采用了一种更加健壮的方式来确定丢包。这个方式是独立于QUIC开发的，加做RACK-TLP：Recent Acknowledgements and Tail Loss Probes。重复的ACK在某些场合是不能工作的，例如发送端在丢包之后并没有发送足够多的数据来触发重复ACK，又比如重传包自己又丢失了。同样的，包乱序也会触发快速重传，而此时并没有丢包。QUIC通过RACK-TLP中的两个机制来解决这里的问题：

* 一个packet，如果“等待了足够长的时间”之后，或者在其之后的第K个packet被ACK时还未被ACK，那么就认为它丢包了。其中K是一个参数。这样可以确保少量的包乱序不会被认为时丢包。K一般最初设置为3，但是当有证据表明有更大的包乱序时，可以被更新成更大的值。等待了”足够长的时间”是指略多于当前测量的RTT。
* 如果在“Probe timeout interval”之后，还未收到packet的ACK。那么就发送探测包，以触发一个ACK来获取有关丢包的信息。这样，即使没有额外的数据来触发重复的ACK，探测包也会引出更多的ACK，从而找到接收端丢失的数据。“Probe timeout interval”会被设置成足够长，以包括ACK可能遇到的所有延时，也就是预估的RTT以及其变化值的预估。

QUIC是当今世界最有意思的传输协议研究之一。TCP有很多限制已经存在了数十年，但是QUIC代表了能够撼动TCP地位的最成功尝试之一。它同时也将TCP几十年来基于实际经验改良的拥塞控制算法作为基本能力集成进来。因为QUIC来源于HTTP以及Web的经验，它们是在TCP已经在互联网完全部署之后很久才兴起的，所以它是一个展示了分层设计所带来的意想不到后果的绝妙例子。有关QUIC还有很多内容，其定义在RFC9000，其拥塞控制算法在RFC9002。

_更多阅读：_

_J. Iyengar and I. Swett, Eds._ [_QUIC Loss Detection and Congestion Control_](https://www.rfc-editor.org/info/rfc9002)_. RFC 9002, May 2021._

