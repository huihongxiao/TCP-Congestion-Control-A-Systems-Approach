# 5.2 不同的假设

针对不同的场景和不同的假设，TCP Vegas以及类似的拥塞规避算法一直在演进。Vegas从来没有像Reno一样广泛部署过，所以它的修改通常是由实验室研究驱动，而不是来自于广泛的真实世界的经验。尽管如此，这些改进和修改也提升了我们对于拥塞规避算法的认知。这里我们总结了一些案例，但会在第7章回到为特定的用户场景定制拥塞控制算法来。

## 5.2.1 FAST TCP

第一个受Vegas启发的机制是FAST TCP，它将Vegas修改成在拥有大的带宽延时积的高速网络上更加有效。它的想法是，在算法尝试找到可用的带宽过程中（也就是在packet开始在网络设备中缓存之前），更加激进的增加拥塞窗口；当算法尝试与其他TCP流在瓶颈路由器竞争时，更加保守。FAST TCP推荐将α修改成大概30个packet大小。

除了管理高带宽延时的线路的拥塞控制，以便保持线路充分利用，FAST TCP还有两个部分值得注意。首先，TCP Reno和TCP Vegas都来源于一点理论和大量的试错，而FAST来源于纯理论，它常被用来说明为什么Vegas能工作。其次，不像其他我们所知道的TCP拥塞控制算法，FAST的实现只在私有解决方案中存在。

_更多阅读：S. Low, L. Peterson, and L. Wang._ [_Understanding TCP Vegas: A Duality Model._](https://dl.acm.org/doi/10.1145/506147.506152)_. Journal of the ACM, Volume 49, Issue 2, March 2002._

## 5.2.2 TCP Westwood

TCP Vegas的出发点是：拥塞可以在实际丢包之前被探测和避免。TCP Westwood（TCPW）的出发点是，丢包并不总是一个可靠的表示拥塞的指标。这在无线网络中尤为明显，无线网络在TCP Vegas提出时还比较新颖，等到TCPW提出时，无线网络已经变得很普遍了。无线链路通常会因为无线信道上存在无法纠正的错误而丢包，这里的丢包与拥塞没有关系。因此，需要有另一种方式来探测拥塞。有趣的是，最终的方法某种程度与TCP Vegas类似，TCPW也会通过检查成功发送包其ACK返回的速度来确定网络的瓶颈带宽。

当丢包发生时，TCPW并不会立即将拥塞窗口减半，因为此时它还不知道丢包是因为拥塞还是因为链路，所以这相比于TCP Reno的回退没那么激进。首先，TCPW会预估在丢包发生之前的传输速率。如果丢包与拥塞相关，TCPW会按照丢包前的速率继续发包。如果丢包是由于无线网络故障，TCPW还没有回退的太多，并且会开始加速增长以充分利用网络。这样就得到了一个算法，它在固定链路上表现的与Reno类似，但是在易丢包的链路上表现的比Reno出色的多。

在无线链路上调整拥塞控制算法一直都是一个有挑战的问题，更复杂的是，WiFi和移动蜂窝网络有着不同的特性，我们将会在第7章回顾这部分。

## 5.2.3 New Vegas

最后一个例子就是 New Vegas（NV）。Vegas根据延时实现拥塞控制，NV 是其一个用于数据中心内部的一个变种。数据中心内部通常是 10Gbps 的带宽，几十微秒的延时，数据中心是一个非常重要的场景，我们将在第 7 章再看。这里介绍 NV 是为了建立一些背景知识。

为了理解 NV 的基本思想，我们在每收到一个 ACK 时，将 `Rate` 和 `CongestionWindow` 画在一个坐标里。在这里，速率简单地指已被确认的数据包的拥塞窗口（以字节为单位）与往返时间（以秒为单位）的比例。这里我们从简单的角度使用 `CongestionWindow`来讨论，然而在实际中，NV 使用传输中（未被确认的）字节数来计算。收集了一段时间的数据，我们得到了图 31。图中每个 `CongestionWindow` 对应的`Rate`是一个垂直条而不是一个点，这是因为存在偶发的拥塞和测试的不准确性。

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1).png" alt=""><figcaption><p>图 31：拥塞窗口和速率的对应关系</p></figcaption></figure>

垂直条顶部的数值代表了在过去时间里，同样的 CongestionWindow 能达到的最大速率。在一个理想系统里，垂直条顶部会构成一个穿过原点的直线，这里背后的原因是：只要网络没有拥塞，每个 RTT 里增加发送的数据量（即增加 CongestionWindow），对应的速率也会相应线性增加。

每一次测试的 Rate 和 CongestionWindow 有三种可能：

1. 高于垂直条的上边界。此时 NV 要更新垂直条顶部，以及对应的穿过原点直线的斜率。
2. 正好落在垂直条的上边界（黑色方块）。此时 NV 会增加 `CongestionWindow`。
3. 低于上边界（蓝色方块）。这意味着 当前的速率匹配了之前一个更小的 `CongestionWindow`。在图 31 的例子中，蓝色方块当前的 CongestionWindow 为 18，但是测量的速率却等于 CongestionWindow 为 12 。所以此时应该减小 CongestionWindow。这里的减小是乘法递减而不是立刻完全变更，这样可避免测量的不准确性。为了过滤掉不准确的测量结果，NV 会测量多次，并取最好的结果用来做算法的决策。
