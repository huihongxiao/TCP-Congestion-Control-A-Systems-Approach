# 4.2 加法递增/乘法递减（AIMD）未校正

准确的超时时间是TCP必不可少的构成元素，但它并不是拥塞控制算法的核心，拥塞控制的核心挑战在于预估TCP发送端可以安全的发送多少流量。为此，TCP 为每个连接维护一个新状态变量，我们称之为拥塞窗口/`CongestionWindow`（但你经常会在文献中看到它被称为 `cwnd`，这是拥塞窗口在代码中对应的变量名）。这个变量被TCP的发送端用来限制在特定时间它可以向网络中传输多少数据。

`CongestionWindow`之于拥塞控制，等于`AdvertisedWindow`之于流量控制。在TCP最开始的版本中（注，未包含拥塞控制算法），TCP的发送端被允许发送`AdvertisedWindow`个字节的未确认数据到网络中。加入拥塞控制之后，TCP的发送端被允许发送 min(`AdvertisedWindow`, `CongestionWindow`)个字节的未确认数据到网络中。对应的，第二章中的 TCP EffectiveWindow运算被修改成如下：

<figure><img src="../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

所以，现在TCP发送端的发送速率受限于下面两个组件中更慢的那个：（1）网络（2）接收端。

现在的问题是TCP如何知道`CongestionWindow`的值。不像`AdvertisedWindow`是由TCP接收端发送出来的，没有人会发出一个确定的`CongestionWindow`。所以，TCP的发送端需要基于其感知的网络的拥塞状态，来自己设置`CongestionWindow`的值。具体来说，就是当网络的拥塞程度上升时，降低拥塞窗口的大小；当网络的拥塞程度下降时，增大拥塞窗口的大小。这里的机制通常被称为加法递增/乘法递减（_additive increase/multiplicative decrease, AIMD_）。

那现在的问题又变成了：TCP的发送端如何知道网络拥塞了？答案是当segment在超时时间之后还没有收到ACK，那么就认为packet未能送达且网络当前处于拥塞状态。很少有情况packet是因为传输中的错误而丢的包（注，如CRC错误），因此TCP就是单纯的将超时认为是拥塞的表现，并在超时的时候降低其传输速率。具体来说，每当超时发生了，TCP发送端就将`CongestionWindow`减半。这里的减半行为对应了AIMD里面的乘法递减（注，每次乘以0.5）。

尽管`CongestionWindow`的值是以字节为单位，为了更好的理解乘法递减，还是基于packet来考虑`CongestionWindow`。假设`CongestionWindow`当前时16个packets大小，当丢包被探测到的时候（也就是超时发生了），`CongestionWindow`会被设置为8。（通常来说，丢包探测时基于超时，我们在后面的内容会发现，TCP还有另一种机制来探测丢包）如果再来一次丢包，`CongestionWindow`会被设置为4，再来就是2，再来就是1。`CongestionWindow`不允许被设置成小于一个packet的大小，也就是我们在第二章学过的`MSS`。

如果拥塞控制算法只会减少窗口的大小，那它明显也太过保守了。它还要能够增大拥塞窗口来充分利用当前可用的网络容量。这就是AIMD里面的“加法递增”部分。每当TCP发送端成功送出了`CongestionWindow`相当的packets之后（也就是说，在同时送出CongestionWindow对应的packets之后，这些packets都被ACK了），它会为`CongestionWindow`增加相当于1个packet大小。这里递增的效果如图22所示。

<figure><img src="../.gitbook/assets/image (4) (1).png" alt="" width="288"><figcaption><p>图22：加法递增过程中的packet传输，每个RTT之后，CongestionWindow都会增大一个packet</p></figcaption></figure>

实际中，TCP并不会等待整个拥塞窗口相当的ACK都收到之后再增加一个packet到拥塞窗口，而是每次收到一个ACK就给CongestionWindow加一点点。具体来说，每当ACK收到了，拥塞窗口会按照下面的公式增加：

<figure><img src="../.gitbook/assets/image (5) (1).png" alt="" width="375"><figcaption></figcaption></figure>

也就是说，TCP并不是在每个RTT后，再将`CongestionWindow`增大MSS个字节（注，这里的MSS就等同于上面说的packet大小），而是在每收到一个ACK之后，就给`CongestionWindow`增大`MSS`的一部分。假设每个ACK确认收到了`MSS`个字节，那么这里的一部分就是`MSS/CongestionWindow`。

这种连续的增加减少拥塞窗口的行为会在整个TCP连接中一直持续。如果你将CongestionWindow的值画一个基于时间的曲线，你会得到一个锯齿状的图，如图23所示。

<figure><img src="../.gitbook/assets/image (6) (1).png" alt="" width="375"><figcaption><p>图23：典型的TCP拥塞窗口锯齿图</p></figcaption></figure>

AIMD包含了一个很重要的设计理念：相比增加拥塞窗口的大小，TCP的发送端愿意以一种快得多的方式减少其拥塞窗口。假设采用加法递增/加法递减的策略来管理拥塞窗口，也就是每次超时了减少拥塞窗口一个MSS，这种方式相对来说太过激进了。对于拥塞进行快速的响应对于稳定性来说很重要。

对于为什么TCP激进的减少，保守的增加拥塞窗口的大小，有一个直观的解释：窗口过大会导致问题不断累积。假设窗口过大，那么被丢弃的packet会被重传，从而使得拥塞更加严重。如果拥塞发生了，第一要务就是从这种状态中解脱出来。你可以认为AIMD会慢慢的增加传输的数据量来探测拥塞何时发生，然后一旦超时了就认为达到了拥塞，并迅速的从拥塞的边缘回退。

最后，由于超时代表了拥塞，并且会触发乘法递减，TCP需要最精确的超时机制。我们在4.1中已经讨论过了TCP的超时时间计算机制，超时时间由平均的RTT和其波动值决定。
