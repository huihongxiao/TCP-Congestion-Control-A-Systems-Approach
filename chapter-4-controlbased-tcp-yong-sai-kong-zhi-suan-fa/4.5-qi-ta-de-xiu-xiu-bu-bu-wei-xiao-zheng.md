# 4.5 其他的修修补补 未校正

如果我们从TCP的拥塞控制中只能学到一件事情，那就是要面临的问题太过复杂了，有太多细节要处理。通过一些实践经验，TCP还有一系列的增强。接下来会介绍其中的2个。

## 4.5.1 TCP SACK

最初的TCP规范使用了累积的ACK，这意味着TCP接收端会确认在任何丢包前收到的最后一个packet（注，也就是只确认按照顺序接收的最后一个packet）。你可以认为接收端会排列处处所有接收到的packet，任何丢失的packet在接收端的字节流里都是一个缺口。在最初的规范里，即使已经丢失了多个packet，接收端也只能告诉发送端第一个缺口的起始位置。很容易想到，这里信息的缺失会限制发送端有效响应丢包的能力。用来解决这里问题的方法被称为selective acknowledgements，或者SACK。SACK也是一个TCP的扩展，它在Jacobson和Karels的早期工作之后很快就被提出，但是过了好些年才被大众接受，因为很难证明它的有效性。

如果没有SACK，那发送端只有两种合理的策略来应对segment被乱序接收了。

* 悲观的策略。当发生快速重传或者超时重传时，除了重传明显已经丢失的packet（接收端处第一个丢失的packet），同时也重传所有后续的segment。悲观策略假设最坏的情况发生了：所有不确定的packet都丢失了。悲观策略的缺点是，它可能不必要的重传已经被接收端成功接收的segment。
* 乐观的策略。在发生丢包时（由超时或者重复的ACK触发），仅重传相应的那1个segment。乐观策略的缺点是，当一段连续的segment丢失时，要花较长时间才能恢复。而这（注，一段连续的segment丢失）在网络拥塞时是可能发生的。之所以要花较长时间是因为每个segment的丢失，都要等到前一个segment的重传对应的ACK收到了之后才能被发现。也就是说，对于一段连续丢失的segment，每个segment的重传都要消耗一个RTT。

如果有SACK，发送端可以有更好的策略：只重传被选择性确认的segment之间的segment。

SACK需要在连接建立的开始在发送端和接收端之间协商。当使用SACK时，接收端还是按照之前一样回复ACK，并且TCP header中的`Acknowledge`字段的含义也没有变化。但它同时也会在TCP header中确认已接受的乱序的segment。这样发送端就能识别出接收端缺失的数据，并且只重传缺失的segment，而不是重传丢失segment之后的所有segment。

SACK在TCP Reno版本中带来了性能的提升，尤其在一个RTT中多个packet丢包时（因为累积ACK和SACK在只丢一个包时是一样的，所以只有丢多个包才能看出区别）。之后，随着带宽延时积的增加，SACK的效果越来越明显，因为在一个RTT中，有更多packet会在网络中传输。因此SACK在1996年称为了一个IETF标准，对TCP来说是个及时的补充。

## 4.5.2 NewReno

NewReno是源自 MIT 的[Janey Hoe在 1990 年代中期的研究](https://dl.acm.org/doi/10.1145/248156.248180)。它通过在特定丢包情况下智能判断哪些 packet 应该重传，进一步提升了 TCP Reno 的性能。

NewReno 的核心思想时，即使没有 SACK，重复 ACK 也携带了如下信息：丢了多少包以及丢了哪些包。这样发送端可以根据这些信息更智能的决定何时重传一个包。此外，当在一个拥塞窗口内丢失了多个 packet 时，NewReno 可以避免 Reno 中出现的多次对拥塞窗口减半的操作。

NewReno 的细节很多，但是概括起来时这样。当只有一个包丢失时，在收到了 3 个重复 ACK 之后，发送端会重传这个丢失的 packet。当接收端收到了重传的包时，接收端会一次确认所有未被确认的数据，因为重传的包填补了接收端 buffer 的空缺。以此类推，当多个包丢失时，对于第一个重传的 packet，接收端只会确认部分未被确认的 packet（注，也就是确认下一个丢包前的数据）。这样，发送端就知道还有其他的丢包，并立刻发送下一个还未被确认的 packet。这样就可以有更少的超时，因此也会有更少的空闲时间和更少的拥塞窗口的减少。

值得注意的是，NewReno 被记录在 1999-2012 年的 3 个 RFC 中，每一个都修复了前一个的一些问题。这是个理解拥塞控制算法究竟有多复杂的好的例子（尤其还需要考虑到 TCP 重传机制的种种细节），也增加了新算法部署实施的难度。

