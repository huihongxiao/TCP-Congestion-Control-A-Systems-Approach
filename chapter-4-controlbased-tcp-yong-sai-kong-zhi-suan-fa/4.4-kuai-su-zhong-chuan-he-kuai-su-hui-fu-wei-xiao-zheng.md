# 4.4 快速重传和快速恢复 未校正

目前为止描述的拥塞控制机制都来自于 最初的 TCP 拥塞控制算法。它们统一被称作 TCP Tahoe，因为它们包含在 1988 年的 4.3 BSD Unix 的 Tahoe 发行版中。在 Tahoe 被广泛部署之后，发现了一些问题，并随后在 1990 年代早期的TCP Reno（随着 4.3BSD-Reno 发布）中得以解决。这一节描述 Tahoe 遇到的问题，以及 Reno 的解决方法。

简单来说，TCP 超时时间的粗粒度导致了 TCP 在等待超时的过程中，有很长一段时间连接都“死掉”（注，不发送任何数据）。一种启发式算法，称为快速重传（fast retransmit），有时可以比常规的超时机制更快的触发丢包的重传。快速重传并不是替代常规的超时机制，它只是增加一种可以更快探测丢包的方式。

快速重传的核心思想是，每当 TCP 接收端收到一个数据，它都回复一个 ACK，即使当前的序列号已经被 ACK 过了。因此，当一个 packet 乱序到达时，TCP 不能确认 packet 包含的数据，因为之前的数据还未到达，但是 TCP 可以上次相同的 ACK。

第二次发送的，相同的 ACK 被称为重复 ACK（duplicate ACK）。当发送端看到了一个重复 ACK，它就知道接收端必然收到了一个乱序的包，并且之前的包可能已经被丢弃了。当然之前的包也可能只是被耽误了，而不是被丢弃了，所以发送端会等待知道看到足够多的重复 ACK（实际中 3 个），再判断发生了丢包，并重传。这里的假设是，并且也经过了大量的实际测试，包的乱序传输比丢包要少的多。

<figure><img src="../.gitbook/assets/image (1).png" alt="" width="325"><figcaption><p>图 26：基于重复 ACK 的快速重传</p></figcaption></figure>

图 26 展示了重复 ACK 时如何触发快速重传的。在这个例子里，接收端收到了 packet 1 和 2，但是 packet 3被网络丢弃了。因此接收端在收到 packet 4,5,6 时，会回复针对 packet 2 的重复 ACK（为了简化这里的描述，我们这里基于 packet1,2,3 描述，而不是基于序列号描述）。当发送端看到了针对 packet 2 的第三个重复 ACK，也就是 packet 6 触发的，它会重传 packet 3。这里注意的是，当 重传的packet 3到达接收端时，接收端会发送一个累积的 ACK 来确认包括 packet 6在内的所有收到的数据。

<figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption><p>图 27：TCP 快速重传下拥塞控制行为。蓝色线=拥塞窗口随时间变化曲线；顶部实心圆点=发生超时；顶部小短竖线=发包；长竖线=最终会重传的报第一次发送的时间</p></figcaption></figure>

图 27 展示了带有快速重传机制的 TCP 的行为。将之与图 25 ，不包含快速重传，进行对比可以发现，拥塞窗口长时间保持水平，并且没有 packet 发送的过程被消除了。总的来说，在一个典型的 TCP 连接中，快速重传可以消除大概一半粗粒度的超时重传，带来大概 20% 的吞吐提升。但是需要注意的时，快速重传并没有消除全部的粗粒度超时重传。这是由于对于小的窗口，不能有对应的packet来触发重复ACK（注，假设窗口大小只有3个packet，那第1个packet丢弃了，后两个packet也只能产生2个重复ACK）。在足够多的丢包情况下，例如在初始的慢启动阶段，滑动窗口算法最终会阻塞发送方，直到发生超时。实际中，TCP的快速重传机制可以在每个窗口中最多探测3个丢包。

这里还有一个地方可以提升。当快速重传发生时，表明网络正在拥塞，与其说将拥塞窗口缩减至1个packet然后重新开始慢启动，不如用正在传输的ACK来触发packet的发送。这个机制被称为快速恢复（fast recovery）。它有效的消除了当快速重传探测到包之后本来应该有的慢启动过程。例如，它可以避免了图27中的3.8秒到4秒之间的慢启动，直接将拥塞窗口砍半（从22KB到11KB），然后直接开始加法递增。也就说，慢启动只会用在一个连接建立时，或者当粗粒度超时发生时。其他时候，拥塞窗口只是遵循加法递增/乘法递减的模型。
